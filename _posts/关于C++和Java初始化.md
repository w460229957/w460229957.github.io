```
---
title: 关于C++和Java初始化
date: 2023-02-12 16:24:00 -0700
categories: [编程语言, 普遍]
tags: [java&c++]     # TAG names should always be lowercase
---
```

关于C++不同类型的初始化，一定要牢记built-in type和class type的区别。例如，在built-in类型中，默认初始化的结果是未决定的，这跟C语言中全部built-in type的初始值都设为0是不同的。而在class类型中，默认初始化仅在class存在至少一个class类型成员的情况下才会调用该成员的默认初始化器（如果有的话)对于那些非class的成员的built-in 类型，它们的值依然是未决定的。

1.C++的七种初始化

1. 默认初始化

2. 值初始化

3. 直接初始化

4. 拷贝初始化

   Universal initialization{}：

5. 列表初始化

6. 聚合初始化

7. 零初始化

2.关于C++中in-class initializer和默认初始化，聚合初始化以及总体上构造器初始化优先顺序的小细节

3.对比C++的七种初始化和Java的四种初始化

4.Java构造函数的顺序



1.默认初始化（Default initialization）：

​	int a; // default-initialized to indeterminate value
​	std::string s; // default-initialized to empty string

- 对于内置类型， 默认初始化不会为变量提供初始值，变量的值是不确定的，取决于它的上下文。
- 对于类类型，默认初始化调用默认构造函数（如果有的话）或将对象保持在未初始化状态（如果没有默认构造函数）。

2.值初始化（value initialization）.仔细观察就能发现，零初始化和值初始化其实没区别。

int a = int(); // value-initialized to 0
std::string s = std::string(); // value-initialized to empty string

3.直接初始化（direct initialization）

int a(42); // direct-initialized to 42
std::string s("hello"); // direct-initialized to "hello"

-   对于内置类型和类类型，直接初始化使用指定的参数调用相应的构造函数。

4.拷贝初始化（copy initialization）

int a = 42; // copy-initialized to 42
std::string s = "hello"; // copy-initialized to "hello"

- 对于内置类型，拷贝初始化将变量初始化为初始值。
- 对于类类型，拷贝初始化调用适当的构造函数创建一个具有初始值的新对象

5.列表初始化（List initialization）

int a{42}; // list-initialized to 42
std::string s{"hello"}; // list-initialized to "hello"
std::vector<int> v{1, 2, 3}; // list-initialized to {1, 2, 3}

- 对于内置类型，列表初始化使用提供的值初始化变量。
- 对于类类型，列表初始化首先尝试调用匹配提供的参数的构造函数。如果没有这样的构造函数，则执行聚合初始化。

6.聚合初始化（aggregate initialization）

struct Point {
    int x;
    int y;
};

Point p = {1, 2}; // aggregate-initialized to {1, 2}

- 聚合初始化仅适用于类类型。它按照类定义中列出的顺序使用提供的值初始化对象。

7.零初始化（zero initialization）

int a{}; // zero-initialized to 0
char c{}; // zero-initialized to '\0'
Point p{}; // zero-initialized to {0, 0} (since it's an aggregate) 

**其实抛开这些或者那些种种，所谓的7种初始化其实可以被看做3种初始化。**

1.第一种初始化，就是源于C语言的初始化。如 int x(7) 或者User user("Joe"). 这种初始化是**直接初始化**。即，直接调用对应的构造函数。

2.第二种初始化，也是源于C语言的初始化。如 int x = 7 或者User user = user("Joe").这种初始化是**复制初始化**。即，先调用默认构造函数，再调用对应的参数构造函数，并将用默认构造函数写成的值给覆盖掉。这种初始化还有一种形式，就是 对于聚合类型，也就是说包含了任何类型的类型，我们可以使用 Point point = {1，2}. 这也是前文所说的，聚合初始化。当然，值得注意的是，由于大多数C++编译器都有着不错的优化策略。通常来说，它们发现了这种形式的初始化时，**会将其优化为直接初始化**。所以从初始化的角度来看，复制初始化和直接初始化在实际实践中区别是没有的。**这种初始化是允许向下转换的。比如从double转成long甚至int**

3.第三种初始化，是C++11引入的”**万能初始化**“。格式为 int x{} || int x{7}. 为了讨论的方便，这种花括号在之后的讨论中会被称为**初始化列表**（initializer list）。从语法形式上来看，这种类型初始化的原则可以通过以下两个rule of thumb来判断

对于class和struct以及内置类型，**初始化列表中元素的数量和每个元素的类型，从左到右，一一对应于类型构造器中每个参数的类型和数量。**如果一个类型的所有构造器函数的都无法跟初始化列表中值的类型完全对应，**并且**也不存在任何向上转换便可以完全对应的构造函数，则**无法编译**。**这种类型初始化是不允许潜在类型向下转换的**。

对于操作上跟数组操作差不多的**顺序容器**和**数组**本身，**初始化列表的数量如果小于这些类型定义时的初始容量**，则多出来的元素全部执行默认构造器。对于built-in或者内置类型来说，它们的默认构造器永远都是把它们的值设为0。值得注意的是，之所以顺序容器支持这样的操作，其原因是它们自身有一个构造函数的参数为std::initializer_list。



2.关于C++中in-class initializer和默认初始化，聚合初始化以及总体上构造器初始化优先顺序的小细节

如果一个类型的属性没有在构造器中初始化，而是直接对其进行了使用=号的初始化，则这种便是in-class initializer。任何使用in-class initializer进行初始化的属性，不能同时具有static 和const修饰符，并且构造函数会忽略这些值。

默认初始化：如果成员没有被明确初始化，它将被默认初始化。对于内置类型，这意味着该成员将具有不确定的值。对于类类型，将调用默认构造函数来初始化成员。

构造函数初始化：如果成员使用构造函数参数进行初始化，则类内初始值设定符将被忽略，并使用提供的参数初始化该成员。

聚合初始化：如果成员是聚合的一部分（例如，数组，结构体或没有用户声明构造函数的类），则可以使用聚合初始化语法进行初始化。在这种情况下，类内初始值设定符将被忽略，并使用提供的值初始化成员。



3.对比C++的七种初始化和Java的四种初始化

当涉及到变量和对象的初始化时，Java有四种不同类型的初始化方式：

1. 声明初始化：这种初始化方式用于在声明变量时进行初始化。例如，`int x = 10;` 声明了一个整数变量 `x`，并将其初始化为 10。
2. 静态初始化：这种初始化方式用于初始化静态变量或静态代码块。静态初始化仅在类加载到内存时发生一次，并按照它们声明的顺序初始化静态变量或静态代码块。
3. 实例初始化：这种初始化方式用于初始化实例变量或实例代码块。实例初始化在每次创建类的新实例时发生，并按照它们声明的顺序初始化实例变量或实例代码块。
4. 构造函数初始化：这种初始化方式用于在构造函数中初始化实例变量。构造函数是一个特殊的方法，当创建类的新对象时会被调用。在构造函数中，可以使用传递给构造函数的参数或其他值或方法来初始化对象的实例变量。

Java没有与C++中的in-class initializer等价的初始化类型。相反，所有实例变量的初始化必须在构造函数或实例初始化块中完成。



4.Java构造函数的顺序

在Java中，如果一个类声明中包含四种初始化类型（声明初始化、静态初始化、实例初始化和构造函数初始化），则初始化的顺序如下：

1. 静态初始化块和静态变量初始化器按照它们在源代码中出现的顺序执行。
2. 实例初始化块和实例变量初始化器按照它们在源代码中出现的顺序执行
3. 执行构造函数体中的超类构造函数（如果有的话）。
4. 最后，执行在调用超类构造函数（如果有的话）之后的构造函数中剩余的语句。



