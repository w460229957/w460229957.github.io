---
title: 关于C++和Java初始化
date: 2023-02-12 16:24:00 -0700
categories: [编程语言, 普遍]
tags: [java&c++]     # TAG names should always be lowercase
---

`[[toc]]`

## 概述

C++和Java有着非常不同的关于类型初始化的规则和语义。总体来看，由于C++语言设计上追求全面兼容各种编程风格和范式，因此初始化的各种类型尤为复杂。而Java则有着更为简单和统一的初始化规则。关于C++不同类型的初始化，一定要牢记built-in type和class type的区别。例如，在built-in类型中，默认初始化的结果是未决定的，这跟C语言中全部built-in type的初始值都设为0是不同的。而在class类型中，默认初始化仅在class存在至少一个class类型成员的情况下才会调用该成员的默认初始化器（如果有的话)对于那些非class的成员的built-in 类型，它们的值依然是未决定的。关于Java的初始化，则需注意静态初始化块和实例初始化块的区别。静态初始化块**只有在类被加载入JVM**时才会运行一次，而实例初始化块则是每次类的**实例创建时**便会运行一次。



## C++的初始化

先来看看C++的七种初始化，这是通常我们所说的标准分类。我的朋友说C++其实有14种初始化，先不去背那么多初始化。正如维特根斯坦的名言：“一切都是语言的游戏....我们要问的是这有**什么意义**。”在没有正式遇到需要考虑更多初始化的时候，先考虑这七种常见的我认为就足够了。

1.默认初始化（Default initialization）：

​	int a; // default-initialized to indeterminate value
​	std::string s; // default-initialized to empty string

- 对于内置类型， 默认初始化不会为变量提供初始值，变量的值是不确定的，取决于它的上下文。
- 对于类类型，默认初始化调用默认构造函数（如果有的话）或将对象保持在未初始化状态（如果没有默认构造函数）。

2.值初始化（value initialization）.仔细观察就能发现，零初始化和值初始化其实没区别。

int a = int(); // value-initialized to 0
std::string s = std::string(); // value-initialized to empty string

3.直接初始化（direct initialization）

int a(42); // direct-initialized to 42
std::string s("hello"); // direct-initialized to "hello"

-   对于内置类型和类类型，直接初始化使用指定的参数调用相应的构造函数。

4.拷贝初始化（copy initialization）

int a = 42; // copy-initialized to 42
std::string s = "hello"; // copy-initialized to "hello"

- 对于内置类型，拷贝初始化将变量初始化为初始值。
- 对于类类型，拷贝初始化调用适当的构造函数创建一个具有初始值的新对象

5.列表初始化（List initialization）

int a{42}; // list-initialized to 42
std::string s{"hello"}; // list-initialized to "hello"
std::vector<int> v{1, 2, 3}; // list-initialized to {1, 2, 3}

- 对于内置类型，列表初始化使用提供的值初始化变量。
- 对于类类型，列表初始化首先尝试调用匹配提供的参数的构造函数。如果没有这样的构造函数，则执行聚合初始化。

6.聚合初始化（aggregate initialization）

struct Point {
    int x;
    int y;
};

Point p = {1, 2}; // aggregate-initialized to {1, 2}

- 聚合初始化仅适用于类类型。它按照类定义中列出的顺序使用提供的值初始化对象。

7.零初始化（zero initialization）

int a{}; // zero-initialized to 0
char c{}; // zero-initialized to '\0'
Point p{}; // zero-initialized to {0, 0} (since it's an aggregate) 

[TOC]



### 关于将C++七种初始化的简化为三种初始化的心智模型

其实抛开这些或者那些种种，我认为所谓的7种初始化其实可以被看做3种初始化。

1.第一种初始化，就是源于C语言的初始化。如 int x(7) 或者User user("Joe"). 这种初始化是**直接初始化**。即，直接调用对应的构造函数。

2.第二种初始化，也是源于C语言的初始化。如 int x = 7 或者User user = user("Joe").这种初始化是**复制初始化**。即，先调用默认构造函数，再调用对应的参数构造函数，并将用默认构造函数写成的值给覆盖掉。这种初始化还有一种形式，就是 对于聚合类型，也就是说包含了任何类型的类型，我们可以使用 Point point = {1，2}. 这也是前文所说的，聚合初始化。当然，值得注意的是，由于大多数C++编译器都有着不错的优化策略。通常来说，它们发现了这种形式的初始化时，**会将其优化为直接初始化**。所以从初始化的角度来看，复制初始化和直接初始化在实际实践中区别是没有的。**这种初始化是允许向下转换的。比如从double转成long甚至int**

3.第三种初始化，是C++11引入的”**万能初始化**“。格式为 int x{} || int x{7}. 为了讨论的方便，这种花括号在之后的讨论中会被称为**初始化列表**（initializer list）。从语法形式上来看，这种类型初始化的原则可以通过以下两个rule of thumb来判断

对于class和struct以及内置类型，**初始化列表中元素的数量和每个元素的类型，从左到右，一一对应于类型构造器中每个参数的类型和数量。**如果一个类型的所有构造器函数的都无法跟初始化列表中值的类型完全对应，**并且**也不存在任何向上转换便可以完全对应的构造函数，则**无法编译**。**这种类型初始化是不允许潜在类型向下转换的**。

对于操作上跟数组操作差不多的**顺序容器**和**数组**本身，**初始化列表的数量如果小于这些类型定义时的初始容量**，则多出来的元素全部执行默认构造器。对于built-in或者内置类型来说，它们的默认构造器永远都是把它们的值设为0。值得注意的是，之所以顺序容器支持这样的操作，其原因是它们自身有一个构造函数的参数为std::initializer_list。

[TOC]



### 关于C++中in-class initializer和默认初始化，聚合初始化以及总体上构造器初始化优先顺序的小细节

如果一个类型的属性没有在构造器中初始化，而是直接对其进行了使用=号的初始化，则这种便是in-class initializer。任何使用in-class initializer进行初始化的属性，不能同时具有static 和const修饰符，并且构造函数会忽略这些值。

默认初始化：如果成员没有被明确初始化，它将被默认初始化。对于内置类型，这意味着该成员将具有不确定的值。对于类类型，将调用默认构造函数来初始化成员。

构造函数初始化：如果成员使用构造函数参数进行初始化，则类内初始值设定符将被忽略，并使用提供的参数初始化该成员。

聚合初始化：如果成员是聚合的一部分（例如，数组，结构体或没有用户声明构造函数的类），则可以使用聚合初始化语法进行初始化。在这种情况下，类内初始值设定符将被忽略，并使用提供的值初始化成员。



## Java的初始化

### Java的四种初始化方式

当涉及到变量和对象的初始化时，Java有四种不同类型的初始化方式：

1. 声明初始化：这种初始化方式用于在声明变量时进行初始化。例如，`int x = 10;` 声明了一个整数变量 `x`，并将其初始化为 10。
2. 静态初始化：这种初始化方式用于初始化静态变量或静态代码块。静态初始化仅在类加载到内存时发生一次，并按照它们声明的顺序初始化静态变量或静态代码块。
3. 实例初始化：这种初始化方式用于初始化实例变量或实例代码块。实例初始化在每次创建类的新实例时发生，并按照它们声明的顺序初始化实例变量或实例代码块。
4. 构造函数初始化：这种初始化方式用于在构造函数中初始化实例变量。构造函数是一个特殊的方法，当创建类的新对象时会被调用。在构造函数中，可以使用传递给构造函数的参数或其他值或方法来初始化对象的实例变量。

Java没有与C++中的in-class initializer等价的初始化类型。在Java中，所有实例变量的初始化必须在构造函数或实例初始化块中完成。



### Java构造函数的顺序

在Java中，如果一个类声明中包含四种初始化类型（声明初始化、静态初始化、实例初始化和构造函数初始化），则初始化的顺序如下：

1. 静态初始化块和静态变量初始化器按照它们在源代码中出现的顺序执行。
2. 实例初始化块和实例变量初始化器按照它们在源代码中出现的顺序执行
3. 执行构造函数体中的超类构造函数（如果有的话）。
4. 最后，执行在调用超类构造函数（如果有的话）之后的构造函数中剩余的语句。



## 结语：从实用主义的角度出发学习语言

这么多的规则，整天浪费时间要背的话是一种浪费生命的行为。实际上，我认为上面的笔记只能作为忘记的时候的参考，而不是某种需要死记硬背的东西。C++和Java的诞生，或者说一切语言的诞生在我看来都是要解决某种现实问题的。在学习时切莫过于关注细枝末节，纠结于“茴”字有多少种写法，而是要从项目的实际出发，多写项目，多体会项目才能更好的自上而下的理解一门语言。正如外语的学习需要跟外国人的实际交流才能最终熟练，编程语言的熟练更是需要实打实地去写代码而不是背和看书才能真正掌握。

